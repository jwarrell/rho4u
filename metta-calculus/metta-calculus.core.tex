\section{A symmetric reflective higher order concurrent calculus with backchaining}

\begin{mathpar}
  \inferrule* [lab=process] {} {P, Q \bc \pzero \;\bm\; \mathsf{for}( t \sngllrarrow x )P \;\bm\; \mathsf{*}x \;\bm\; P\mathsf{|}Q }
  \and
  \inferrule* [lab=name] {} {x, y \bc \mathsf{@}P } \\
  \and
  \inferrule* [lab=term] {} {t, u \bc atom \;\bm\; \mathsf{(}t^{*}\mathsf{)}} \\
  \and
  \inferrule* [lab=term] {} {atom \bc x \;\bm\; \mathsf{Bool} \;\bm\; \mathsf{String} \;\bm\; \mathsf{Int} \;\bm\; P}
\end{mathpar}

\begin{mathpar}
  \inferrule* [lab=equiv] {} {P\mathsf{|}\pzero \equiv P \;\; P\mathsf{|}Q \equiv Q\mathsf{|}P \;\; P\mathsf{|}(Q\mathsf{|}R) \equiv (P\mathsf{|}Q)\mathsf{R}} \\
  \and
  \inferrule* [lab=alpha] { \mathsf{occurs}(t,y)} {\mathsf{for}(t \sngllrarrow x )P \equiv \mathsf{for}(t\{z/y\} \sngllrarrow x )(P\{z/y\}) \; \mathsf{if} z \notin \mathsf{FN}(P)}
\end{mathpar}

\begin{mathpar}
  \inferrule* [lab=COMM] {\sigma = \mathsf{unify}(t,u)} {\mathsf{for}( t \sngllrarrow x )P \;\mathsf{|}\; \mathsf{for}( u \sngllrarrow x )Q
    \red P\dot{\sigma}\mathsf{|}Q\dot{\sigma}} \\
  \and
  \inferrule* [lab=PAR]{P \red P'}{P\mathsf{|}Q \red P'\mathsf{|}Q}
  \and
  \inferrule* [lab=EQUIV]{{P \;\scong\; P'} \andalso {P' \red Q'} \andalso {Q' \;\scong\; Q}}{P \red Q} \\
  \and
  \inferrule* [lab=REFL] {P \red P'} {x\mathsf{?}P \red x\mathsf{!}\mathsf{(}P'\mathsf{)}} \\
\end{mathpar}

where $\dot{\sigma}$ denotes the substitution that replaces all variable to process bindings with variable to name bindings. Thus, $\dot{\{P / x\}} = \{\mathsf{@}P / x\}$.

\subsection{Intuitive mapping to $\mathsf{MeTTa}$}

\begin{center}
\begin{tabular}{ c c }
  $\mathsf{MeTTa}$ language & $\mathsf{MeTTa}$ calculus \\ 
  $\mathsf{(}\mathsf{addAtom}\; space \; term \mathsf{)}$ & $\mathsf{for}( term \;\sngllrarrow\; space )\mathsf{0}$ \\
  $\mathsf{(}\mathsf{remAtom}\; space \; term \mathsf{)}$ & $\mathsf{for}( term \;\sngllrarrow\; space )\mathsf{0}$ \\
  $\mathsf{(}\mathsf{?}\; space\; term \mathsf{)}$ & $\mathsf{for}( term \;\sngllrarrow\; space )\mathsf{0}$ \\  
\end{tabular}
\end{center}

\section{Some useful features}

\subsection{Replication and freshness}
\begin{mathpar}
  \inferrule* [lab=process] {} {P, Q \bc \ldots \;\bm\; \mathsf{!}P \;\bm\; \mathsf{new}\; x\; \mathsf{in}\; \mathsf{\{} \;P\; \mathsf{\}}}
\end{mathpar}

In the core calculus, when two terms rendezvous at a space
($\mathsf{for}( t \sngllrarrow x )P \;\mathsf{|}\; \mathsf{for}( u
\sngllrarrow x )Q$) they are \emph{consumed} and replaced by their
continuations ($P\dot{\sigma}\mathsf{|}Q\dot{\sigma}$). It is
frequently useful in programming applications to leave one or the
other in place. Thus, when $\mathsf{!}\mathsf{for}( t \sngllrarrow x )P$ rendezvous with $\mathsf{for}( u \sngllrarrow x )Q$ it reduces to $\mathsf{!}\mathsf{for}( t \sngllrarrow x )P\mathsf{|}P\dot{\sigma}\mathsf{|}Q\dot{\sigma}$. 

Likewise, in programming applications it is often useful to guarantee that computations rendezvous in a private space. The state denoted by $\mathsf{new}\; x\; \mathsf{in}\; \mathsf{\{} \;P\; \mathsf{\}}$ guarantees that $x$ is private in the scope $P$. Therefore, $\mathsf{new}\; x\; \mathsf{in}\;\mathsf{\{}\;\mathsf{for}( t \sngllrarrow x )P \;\mathsf{|}\; \mathsf{for}( u \sngllrarrow x )Q\mathsf{\}\;}$ guarantees that the rendezvous happens in a private space.

\subsection{Fork-join concurrency}

This next bit of syntactic sugar illustrates the value of the
$\mathsf{for}$-comprehension. Specifically, it facilitates the
introduction of fork-join concurrency, which is predominant in human
decision-making processes. The following syntax should be read as an
expansion of the core calculus, \emph{replacing} the much simpler
$\mathsf{for}$-comprehension with a more articulated one.

\begin{mathpar}
  \inferrule* [lab=process] {} {P, Q \bc \ldots \;\bm\; \mathsf{for}( [\mathsf{Join}] )P} \\
  \and
  \inferrule* [lab=joins] {} { [\mathsf{Join}] \bc \mathsf{Join} \;\bm\; \mathsf{Join} \mathsf{;} [\mathsf{Join}]} \\
  \and
  \inferrule* [lab=join] {} { \mathsf{Join} \bc [\mathsf{Query}]} \\
  \and
  \inferrule* [lab=queries] {} { [\mathsf{Query}] \bc \mathsf{Query} \;\bm\; \mathsf{Query} \mathsf{\&} [\mathsf{Query}]} \\
  \and
  \inferrule* [lab=query] {} { \mathsf{Query} \bc t \;\sngllrarrow\; x} \\
\end{mathpar}

In case the $\mathsf{BNF}$ is a little opaque, here is the template.

\begin{lstlisting}[mathescape=true]
  for(
    y$_{11}$ $\sngllrarrow$ x$_{11}$ & $\ldots$ & y$_{m1}$ $\sngllrarrow$ x$_{m1}$ ; // received in any order, 
       $\dots$ ; // but all received before the next row
    y$_{1n}$ $\sngllrarrow$ x$_{1n}$ & $\ldots$ & y$_{mn}$ $\sngllrarrow$ x$_{mn}$
  ){ $P$ }
\end{lstlisting}
