\section{Appendix :  reflection in more detail}\label{appendix:rho_details}

\subsection{Name equivalence}

We now come to one of the first real subtleties of this calculus as
compared to other process calculi. Both the calculation of the free
names of a process and the determination of structural congruence
between processes critically depend on being able to establish whether
two names are equal. In the case of the calculation of the free names
of an input-guarded process, for example, to remove the bound name we
must determine whether it is in the set of free names of the
continuation. Likewise, structural congruence includes
$\alpha$-equivalence. But, establishing $\alpha$-equivalence between
the processes $x?(z).\lift{w}{y!(z)}$ and $x?(v).\lift{w}{y!(v)}$, for
instance, requires calculating a substitution,
e.g. $x?(v).\lift{w}{y!(v)}\{z / v \}$. But this calculation requires,
in turn, being able to determine whether two names, in this case the
name in the object position of the output, and the name being
substituted for, are equal.

As will be seen, the equality on names involves structural equivalence
on processes, which in turn involves alpha equivalence, which involves
name equivalence. This is a subtle mutual recursion, but one that
turns out to be well-founded. Before presenting the technical details,
the reader may note that the grammar above enforces a strict
alternation between quotes and process constructors. Each question
about a process that involves a question about names may in turn
involve a question about processes, but the names in the processes the
next level down, as it were, are under fewer quotes. To put it another
way, each `recursive call' to name equivalence will involve one less
level of quoting, ultimately bottoming out in the quoted zero process.

Let us assume that we have an account of (syntactic) substitution and
$\alpha$-equivalence upon which we can rely to formulate a notion of
name equivalence, and then bootstrap our notions of substitution and
$\alpha$-equivalence from that. We take name equivalence, written
$\nameeq$, to be the smallest equivalence relation generated by the
following rules.

\begin{mathpar}
\inferrule*[left=Quote-drop]
{ }
{ \quotep{\dropn{x}} \nameeq x }

\inferrule*[right=Struct-equiv]
{ P \scong Q }
{ \quotep{P} \nameeq \quotep{Q} }
\end{mathpar}

\subsection{Syntactic substitution}

Now we build the substitution used by $\alpha$-equivalence. We use
$\Proc$ for the set of processes, $\QProc$ for the set of names, and
$\id{\{}\arrvec{y} / \arrvec{x} \id{\}}$ to denote partial maps, $s : \QProc
\rightarrow \QProc$. A map, $s$ lifts, uniquely, to a map on process
terms, $\widehat{s} : \Proc \rightarrow \Proc$ by the following
equations.

\begin{mathpar}
(0) \psubstp{Q}{P}         :=    0 \\
(R \juxtap S) \psubstp{Q}{P}
		:=    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \\
(x?(y).R) \psubstp{Q}{P}    
		:=    
		(x)\substp{Q}{P} (z)\concat( (R \psubstn{z}{y}) \psubstp{Q}{P} ) \\
(\lift{x}{R}) \psubstp{Q}{P}  
 		:=
 		\lift{(x)\substp{Q}{P}}{ R \psubstp{Q}{P} } \\
(\dropn{x})  \psubstp{Q}{P}       
		:= 
		\left\{ 
			\begin{array}{ccc} 
				\dropn{\quotep{Q}} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right. 
\end{mathpar}
 

where

\begin{eqnarray}
(x)\id{\{} \lpquote Q \rpquote / \lpquote P \rpquote \id{\}}            = 
		\left\{ 
			\begin{array}{ccc}
				\lpquote Q \rpquote & & x \nameeq \lpquote P \rpquote \\
                                x & & otherwise \\
			\end{array}
		\right. \nonumber
\end{eqnarray}

and $z$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$. Our $\alpha$-equivalence will
be built in the standard way from this substitution.

But, given these mutual recursions, the question is whether the calculation
of $\nameeq$ (respectively, $\scong$, $\alphaeq$) terminates. To
answer this question it suffices to formalize our intuitions regarding
level of quotes, or quote depth, $\#(x)$, of a name $x$ as
follows.

\begin{eqnarray}
	\#(\quotep{P}) & = & 1 + \#(P) \nonumber\\
    \#(P) & = & \left\{
			   \begin{array}{ccc}
				 max\{ \#(x) : x \in \names{P} \} & & \names{P} \neq \emptyset \\
				 0 & & otherwise \\
			   \end{array}
			\right. \nonumber
\end{eqnarray}

The grammar ensures that $\#(\quotep{P})$ is bounded. Then the
termination of $\nameeq$ (respectively, $\scong$, $\alphaeq$) is an
easy induction on quote depth.

\begin{remark}
  Note that by a related piece of reasoning we can see that $\forall
  P. \quotep{P} \not\in \freenames{P}$.
\end{remark}

\subsection{Semantic substitution}

The substitution used in $\alpha$-equivalence is really only a device
to formally recognize that binding occurrences do not depend on the
specific names. It is not the engine of computation. The proposal here
is that while synchronization is the driver of that engine, the real
engine of computation is a semantic notion of substitution that
recognizes that a dropped name is a request to run a process. Which
process? Why the one whose code has been bound to the name being
dropped. Formally, this amounts to a notion of substitution that
differs from syntactic substitution in its application to a dropped
name.

\begin{eqnarray}
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right. \nonumber
\end{eqnarray}

In the remainder of the paper we will refer to semantic and syntactic
substitutions simply as substitutions and rely on context to
distinguish which is meant. Similarly, we will abuse notation and
write $\substn{y}{x}$ for $\psubstn{y}{x}$.

