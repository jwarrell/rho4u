\section{Useful syntactic sugar}
\begin{mathpar}
\inferrule* [lab=process] {} {\mathsf{Proc} \bc \mathsf{Proc1} \\
 \;\bm\; \mathsf{Proc} \mathsf{|} \mathsf{Proc1} } \\
\inferrule* [lab=conditional] {} {\mathsf{Proc1} \bc \mathsf{Proc2} \\
 \;\bm\; \texttt{if}\; \texttt{(} \mathsf{Proc} \texttt{)}\; \mathsf{Proc2} \\
 \;\bm\; \texttt{if}\; \texttt{(} \mathsf{Proc} \texttt{)}\; \mathsf{Proc2}\; \texttt{else}\; \mathsf{Proc1} \\
 \;\bm\; \texttt{new}\; \mathsf{[NameDecl]}\; \texttt{in}\; \mathsf{Proc1} \\
 \;\bm\; \mathsf{Name}\; \texttt{!?} \texttt{(} \mathsf{[Proc]} \texttt{)}\; \mathsf{SynchSendCont} }\\
\inferrule* [lab=io] {} {\mathsf{Proc2} \bc \mathsf{Proc3} \\
 \;\bm\; \texttt{contract}\; \mathsf{Name}\; \texttt{(} \mathsf{[Name]}\; \mathsf{NameRemainder} \texttt{)}\; \texttt{=}\; \texttt{\{}\; \mathsf{Proc}\; \texttt{\}} \\
 \;\bm\; \texttt{for}\; \texttt{(} \mathsf{[Receipt]} \texttt{)} \texttt{\{} \;\mathsf{Proc}\; \texttt{\}} \\
 \;\bm\; \texttt{select}\; \texttt{\{} \;\mathsf{[Branch]}\; \texttt{\}} \\
 \;\bm\; \texttt{match}\; \mathsf{Proc4}\; \texttt{\{} \;\mathsf{[Case]}\; \texttt{\}} \\
 \;\bm\; \mathsf{Bundle}\; \texttt{\{} \;\mathsf{Proc}\; \texttt{\}} \\
 \;\bm\; \texttt{let}\; \mathsf{Decl}\; \mathsf{Decls}\; \texttt{in}\; \texttt{\{} \;\mathsf{Proc}\; \texttt{\}} }\\
\inferrule* [lab=output] {} {\mathsf{Proc3} \bc \mathsf{Proc4} \\
 \;\bm\; \mathsf{Name} \;\mathsf{Send}\; \texttt{(} \mathsf{[Proc]} \texttt{)}} \\
\inferrule* [lab=disjunction] {} {\mathsf{Proc4} \bc \mathsf{Proc5} \\
 \;\bm\; \mathsf{Proc4} \;\texttt{or}\; \mathsf{Proc5}} \\
\inferrule* [lab=conjunction] {} {\mathsf{Proc5} \bc \mathsf{Proc6} \\
 \;\bm\; \mathsf{Proc5} \;\texttt{and}\; \mathsf{Proc6}} \\
\inferrule* [lab=matching] {} {\mathsf{Proc6} \bc \mathsf{Proc7} \\
\;\bm\; \mathsf{Proc7} \;\texttt{matches}\; \mathsf{Proc7} \\
 \;\bm\; \mathsf{Proc6} \;\texttt{==}\; \mathsf{Proc7} \\
 \;\bm\; \mathsf{Proc6} \;\texttt{!=}\; \mathsf{Proc7}} \\
\inferrule* [lab=comparison] {} {\mathsf{Proc7} \bc \mathsf{Proc8} \\
 \;\bm\; \mathsf{Proc7} \;\texttt{$<$}\; \mathsf{Proc8} \\
 \;\bm\; \mathsf{Proc7} \;\texttt{$<$=}\; \mathsf{Proc8} \\
 \;\bm\; \mathsf{Proc7} \;\texttt{$>$}\; \mathsf{Proc8} \\
 \;\bm\; \mathsf{Proc7} \;\texttt{$>$=}\; \mathsf{Proc8}} \\
\inferrule* [lab=addition] {} {\mathsf{Proc8} \bc \mathsf{Proc9} \\
 \;\bm\; \mathsf{Proc8} \;\texttt{+}\; \mathsf{Proc9} \\
 \;\bm\; \mathsf{Proc8} \;\texttt{-}\; \mathsf{Proc9} \\
 \;\bm\; \mathsf{Proc8} \;\texttt{++}\; \mathsf{Proc9} \\
 \;\bm\; \mathsf{Proc8} \;\texttt{--}\; \mathsf{Proc9}} \\
\inferrule* [lab=multiplication] {} {\mathsf{Proc9} \bc \mathsf{Proc10} \\
 \;\bm\; \mathsf{Proc9} \;\texttt{*}\; \mathsf{Proc10} \\
 \;\bm\; \mathsf{Proc9} \;\texttt{/}\; \mathsf{Proc10} \\
 \;\bm\; \mathsf{Proc9} \;\texttt{\%}\; \mathsf{Proc10} \\
 \;\bm\; \mathsf{Proc9} \;\texttt{\%\%}\; \mathsf{Proc10}} \\
\inferrule* [lab=negation] {} {\mathsf{Proc10} \bc \mathsf{Proc11} \\
 \;\bm\; \texttt{not}\; \mathsf{Proc10} \\
 \;\bm\; \texttt{-} \mathsf{Proc10}} \\
\inferrule* [lab=nesting] {} {\mathsf{Proc11} \bc \mathsf{Proc12} \\
 \;\bm\; \mathsf{Proc11} \texttt{.} \mathsf{Var} \texttt{(} \mathsf{[Proc]} \texttt{)} \\
 \;\bm\; \texttt{(} \mathsf{Proc4} \texttt{)}} \\
\inferrule* [lab=dereference] {} {\mathsf{Proc12} \bc \mathsf{Proc13} \\
 \;\bm\; \texttt{*} \mathsf{Name}} \\
\inferrule* [lab=match-disjuction] {} {\mathsf{Proc13} \bc \mathsf{Proc14} \\
 \;\bm\; \mathsf{VarRefKind} \mathsf{Var} \\
 \;\bm\; \mathsf{Proc13} \;\texttt{$\backslash$/}\; \mathsf{Proc14}} \\
\inferrule* [lab=match-conjunction] {} {\mathsf{Proc14} \bc \mathsf{Proc15} \\
 \;\bm\; \mathsf{Proc14} \;\texttt{/$\backslash$}\; \mathsf{Proc15}} \\
\inferrule* [lab=match-negation] {} {\mathsf{Proc15} \bc \mathsf{Proc16} \\
  \;\bm\; \texttt{\~{}} \mathsf{Proc15}} \\
\end{mathpar}
\begin{mathpar}
\inferrule* [lab=???] {} {\mathsf{Proc16} \bc \texttt{\{} \mathsf{Proc} \texttt{\}} \\
 \;\bm\; \mathsf{Ground} \\
 \;\bm\; \mathsf{Collection} \\
 \;\bm\; \mathsf{ProcVar} \\
 \;\bm\; \texttt{Nil} \\
 \;\bm\; \mathsf{SimpleType}} \\
\inferrule* [lab=???] {} {\mathsf{[Proc]} \bc \textbf{eps} \\
 \;\bm\; \mathsf{Proc} \\
 \;\bm\; \mathsf{Proc} \texttt{,} \mathsf{[Proc]}} \\
\end{mathpar}
%% \mathsf{Decl} \bc \mathsf{[Name]} \mathsf{NameRemainder} \texttt{$<$-} \mathsf{[Proc]} \\
%% \mathsf{LinearDecl} \bc \mathsf{Decl} \\
%% \mathsf{[LinearDecl]} \bc \mathsf{LinearDecl} \\
%%  \;\bm\; \mathsf{LinearDecl} \texttt{;} \mathsf{[LinearDecl]} \\
%% \mathsf{ConcDecl} \bc \mathsf{Decl} \\
%% \mathsf{[ConcDecl]} \bc \mathsf{ConcDecl} \\
%%  \;\bm\; \mathsf{ConcDecl} \texttt{\&} \mathsf{[ConcDecl]} \\
%% \mathsf{Decls} \bc \textbf{eps} \\
%%  \;\bm\; \texttt{;} \mathsf{[LinearDecl]} \\
%%  \;\bm\; \texttt{\&} \mathsf{[ConcDecl]} \\
%% \mathsf{SynchSendCont} \bc \texttt{.} \\
%%  \;\bm\; \texttt{;} \mathsf{Proc1} \\
%% \mathsf{ProcVar} \bc \texttt{\_} \\
%%  \;\bm\; \mathsf{Var} \\
%% \mathsf{Name} \bc \texttt{\_} \\
%%  \;\bm\; \mathsf{Var} \\
%%  \;\bm\; \texttt{@} \mathsf{Proc12} \\
%% \mathsf{[Name]} \bc \textbf{eps} \\
%%  \;\bm\; \mathsf{Name} \\
%%  \;\bm\; \mathsf{Name} \texttt{,} \mathsf{[Name]} \\
%% \mathsf{Bundle} \bc \texttt{bundle+} \\
%%  \;\bm\; \texttt{bundle-} \\
%%  \;\bm\; \texttt{bundle0} \\
%%  \;\bm\; \texttt{bundle} \\
%% \mathsf{Receipt} \bc \mathsf{ReceiptLinearImpl} \\
%%  \;\bm\; \mathsf{ReceiptRepeatedImpl} \\
%%  \;\bm\; \mathsf{ReceiptPeekImpl} \\
%% \mathsf{[Receipt]} \bc \mathsf{Receipt} \\
%%  \;\bm\; \mathsf{Receipt} \texttt{;} \mathsf{[Receipt]} \\
%% \mathsf{ReceiptLinearImpl} \bc \mathsf{[LinearBind]} \\
%% \mathsf{LinearBind} \bc \mathsf{[Name]} \mathsf{NameRemainder} \texttt{$<$-} \mathsf{NameSource} \\
%% \mathsf{[LinearBind]} \bc \mathsf{LinearBind} \\
%%  \;\bm\; \mathsf{LinearBind} \texttt{\&} \mathsf{[LinearBind]} \\
%% \mathsf{NameSource} \bc \mathsf{Name} \\
%%  \;\bm\; \mathsf{Name} \texttt{?!} \\
%%  \;\bm\; \mathsf{Name} \texttt{!?} \texttt{(} \mathsf{[Proc]} \texttt{)} \\
%% \mathsf{ReceiptRepeatedImpl} \bc \mathsf{[RepeatedBind]} \\
%% \mathsf{RepeatedBind} \bc \mathsf{[Name]} \mathsf{NameRemainder} \texttt{$<$=} \mathsf{Name} \\
%% \mathsf{[RepeatedBind]} \bc \mathsf{RepeatedBind} \\
%%  \;\bm\; \mathsf{RepeatedBind} \texttt{\&} \mathsf{[RepeatedBind]} \\
%% \mathsf{ReceiptPeekImpl} \bc \mathsf{[PeekBind]} \\
%% \mathsf{PeekBind} \bc \mathsf{[Name]} \mathsf{NameRemainder} \texttt{$<$$<$-} \mathsf{Name} \\
%% \mathsf{[PeekBind]} \bc \mathsf{PeekBind} \\
%%  \;\bm\; \mathsf{PeekBind} \texttt{\&} \mathsf{[PeekBind]} \\
%% \mathsf{Send} \bc \texttt{!} \\
%%  \;\bm\; \texttt{!!} \\
%% \mathsf{Branch} \bc \mathsf{ReceiptLinearImpl} \texttt{=$>$} \mathsf{Proc3} \\
%% \mathsf{[Branch]} \bc \mathsf{Branch} \\
%%  \;\bm\; \mathsf{Branch} \mathsf{[Branch]} \\
%% \mathsf{Case} \bc \mathsf{Proc13} \texttt{=$>$} \mathsf{Proc3} \\
%% \mathsf{[Case]} \bc \mathsf{Case} \\
%%  \;\bm\; \mathsf{Case} \mathsf{[Case]} \\
%% \mathsf{NameDecl} \bc \mathsf{Var} \\
%%  \;\bm\; \mathsf{Var} \texttt{(} \mathsf{UriLiteral} \texttt{)} \\
%% \mathsf{[NameDecl]} \bc \mathsf{NameDecl} \\
%%  \;\bm\; \mathsf{NameDecl} \texttt{,} \mathsf{[NameDecl]} \\
%% \mathsf{BoolLiteral} \bc \texttt{true} \\
%%  \;\bm\; \texttt{false} \\
%% \mathsf{Ground} \bc \mathsf{BoolLiteral} \\
%%  \;\bm\; \mathsf{LongLiteral} \\
%%  \;\bm\; \mathsf{StringLiteral} \\
%%  \;\bm\; \mathsf{UriLiteral} \\
%% \mathsf{Collection} \bc \texttt{[} \mathsf{[Proc]} \mathsf{ProcRemainder} \texttt{]} \\
%%  \;\bm\; \mathsf{Tuple} \\
%%  \;\bm\; \texttt{Set} \texttt{(} \mathsf{[Proc]} \mathsf{ProcRemainder} \texttt{)} \\
%%  \;\bm\; \texttt{\{} \mathsf{[KeyValuePair]} \mathsf{ProcRemainder} \texttt{\}} \\
%% \mathsf{KeyValuePair} \bc \mathsf{Proc} \texttt{:} \mathsf{Proc} \\
%% \mathsf{[KeyValuePair]} \bc \textbf{eps} \\
%%  \;\bm\; \mathsf{KeyValuePair} \\
%%  \;\bm\; \mathsf{KeyValuePair} \texttt{,} \mathsf{[KeyValuePair]} \\
%% \mathsf{Tuple} \bc \texttt{(} \mathsf{Proc} \texttt{,)} \\
%%  \;\bm\; \texttt{(} \mathsf{Proc} \texttt{,} \mathsf{[Proc]} \texttt{)} \\
%% \mathsf{ProcRemainder} \bc \texttt{...} \mathsf{ProcVar} \\
%%  \;\bm\; \textbf{eps} \\
%% \mathsf{NameRemainder} \bc \texttt{...} \texttt{@} \mathsf{ProcVar} \\
%%  \;\bm\; \textbf{eps} \\
%% \mathsf{VarRefKind} \bc \texttt{=} \\
%%  \;\bm\; \texttt{=} \texttt{*} \\
%% \mathsf{SimpleType} \bc \texttt{Bool} \\
%%  \;\bm\; \texttt{Int} \\
%%  \;\bm\; \texttt{String} \\
%%  \;\bm\; \texttt{Uri} \\
%%  \;\bm\; \texttt{ByteArray} \\
%% \end{mathpar}
\subsection{Pattern matching}
TBD
\subsection{Summation}
TBD
\subsection{Joins}
TBD
\subsection{Unguessable versus unforgeable names}
TBD
\subsection{First class values}
While it is standard in calculi such as the $\lambda$-calculus to
define a variety of common values such as the natural numbers and
booleans in terms of Church-numeral style encodings, it is equally
common to simply embed values directly into the calculus. Not being
higher-order, this presents some challenges for the $\pi$-calculus,
but for the rho-calculus, everything works out very nicely if we treat
values, e.g. the naturals, the booleans, the reals, etc as processes. This
choice means we can meaninfully write expressions like
$x!(\mathsf{5})$ or $u!(\mathsf{true})$, and in the context
$\prefix{x}{y}P[*y] \mathsf{|} x!(\mathsf{5})$ the value $\mathsf{5}$
will be substituted into $P$. Indeed, since operations like addition,
multiplication, etc.  can also be defined in terms of processes, it is
meaningful to write expressions like
$\mathsf{5}\mathsf{|}\mathsf{+}\mathsf{|}\mathsf{1}$, and be confident
that this expression will reduce to a process representing
$\mathsf{6}$. Thus, we can also use standard mathematical expressions,
such as $\mathsf{5+1}$, as processes, and know that these will
evaluate to their expected values. Further, when combined with
$\mathsf{for}$-comprehensions, we can write algebraic expressions,
such as $\prefix{x}{y}\mathsf{5}\mathsf{+}\mathsf{*}y$, and in
contexts like
$(\prefix{x}{y}\mathsf{5}\mathsf{+}\mathsf{*}y)\mathsf{|}\outputp{x}{\mathsf{1}}$
this will evaluate as expected, producing the process (aka value)
$\mathsf{6}$.

With these conventions in place it is useful to reduce the
proliferation of $\mathsf{*}$'s, by adopting a pattern-matching
convention. Thus, we write $\prefix{x}{@v}{P}$ to denote binding $v$
to the value passed and not the \emph{name} of the value. Hence, we
may write $\prefix{x}{@v}{\mathsf{5+v}}$ without any loss of clarity,
confident that this translates unambiguously into the formal calculus
presented above. We achieve even greater compression and a more
familiar notation if we also adopt the notation

\begin{mathpar}
  \mathsf{let}\; x \;\mathsf{=}\; v \;\mathsf{in}\; P := (\mathsf{new} \; u)(\prefix{u}{@x}P)\mathsf{|}\outputp{u}{v}
\end{mathpar}
