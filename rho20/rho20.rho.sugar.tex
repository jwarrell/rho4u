\section{Useful syntactic sugar}

\subsection{First class values}
While it is standard in calculi such as the $\lambda$-calculus to
define a variety of common values such as the natural numbers and
booleans in terms of Church-numeral style encodings, it is equally
common to simply embed values directly into the calculus. Not being
higher-order, this presents some challenges for the $\pi$-calculus,
but for the rho-calculus, everything works out very nicely if we treat
values, e.g. the naturals, the booleans, the reals, etc as processes. This
choice means we can meaninfully write expressions like
$x!(\mathsf{5})$ or $u!(\mathsf{true})$, and in the context
$\prefix{x}{y}P[*y] \mathsf{|} x!(\mathsf{5})$ the value $\mathsf{5}$
will be substituted into $P$. Indeed, since operations like addition,
multiplication, etc.  can also be defined in terms of processes, it is
meaningful to write expressions like
$\mathsf{5}\mathsf{|}\mathsf{+}\mathsf{|}\mathsf{1}$, and be confident
that this expression will reduce to a process representing
$\mathsf{6}$. Thus, we can also use standard mathematical expressions,
such as $\mathsf{5+1}$, as processes, and know that these will
evaluate to their expected values. Further, when combined with
$\mathsf{for}$-comprehensions, we can write algebraic expressions,
such as $\prefix{x}{y}\mathsf{5}\mathsf{+}\mathsf{*}y$, and in
contexts like
$(\prefix{x}{y}\mathsf{5}\mathsf{+}\mathsf{*}y)\mathsf{|}\outputp{x}{\mathsf{1}}$
this will evaluate as expected, producing the process (aka value)
$\mathsf{6}$.

\begin{mathpar}
  \inferrule* [lab=values] {} {P \bc \dots \bm \mathsf{Bool}
    \bm \mathsf{Long}
    \bm \mathsf{String}
    \bm \mathsf{Uri} \bm \mathsf{Collection} \bm \ldots}
\end{mathpar}

\begin{mathpar}
  \inferrule* [lab=collection] {} {\mathsf{Collection} \bc \texttt{[} \mathsf{[}P\mathsf{]} \texttt{]}
    \bm \texttt{(} P \texttt{,}\; \mathsf{[}P\mathsf{]} \texttt{)}
    \bm \texttt{Set} \texttt{(} \mathsf{[}P\mathsf{]} \texttt{)}
    \bm \texttt{\{} \mathsf{[}P \texttt{:} P \mathsf{]} \texttt{\}}} \\
\end{mathpar}

\subsection{Pattern matching}
Remember that rho allows processes to be sent: $x\mathsf{!}(Q)$. Since
we can send values, it will be useful to be able to pattern match on
values. The following pattern-matching syntax captures very commonly
used idioms.

\begin{mathpar}
  \inferrule* [lab=pattern] {} {\mathsf{ProcPattern} \bc \texttt{\_}
    \bm \mathsf{Var}
    \bm \texttt{@} \mathsf{ProcPattern}
    \bm\; \mathsf{VarRefKind}\; \mathsf{Var} \bm \mathsf{LogicalPattern} \bm \mathsf{ValuePattern}} \\
  \and
  \inferrule* [lab=logical-pattern] {} {\mathsf{LogicalPattern} \bc \mathsf{ProcPattern} \;\vee\; \mathsf{ProcPattern}
    \bm \mathsf{ProcPattern} \;\wedge\; \mathsf{ProcPattern}
    \bm \texttt{\~{}} \mathsf{ProcPattern}} \\
  \and
  \inferrule* [lab=value-pattern] {} {\mathsf{ValuePattern} \bc \mathsf{Ground}
    \bm \mathsf{Collection}
    \bm \texttt{Nil}
    \bm \mathsf{SimpleType}} \\
  \and
  \inferrule* [lab=var-ref-kind] {} {\mathsf{VarRefKind} \bc \texttt{=} \bm \texttt{=} \texttt{*}} \\
\end{mathpar}
\subsection{Summation}
\begin{mathpar}
  \inferrule*[lab=summation]{}{\mathsf{P} \bc \ldots \texttt{select}\; \texttt{\{} \;\mathsf{[Branch]}\; \texttt{\}}} \\
  \and
  \inferrule* [lab=] {} {\mathsf{Branch} \bc \mathsf{ReceiptLinearImpl} \texttt{=$>$} \mathsf{Proc3}} \\
\inferrule* [lab=] {} {\mathsf{[Branch]} \bc \mathsf{Branch} \\
 \;\bm\; \mathsf{Branch} \mathsf{[Branch]}} \\
\end{mathpar}
\subsection{Joins}
TBD
\subsection{Unguessable versus unforgeable names}
We achieve even greater compression and a more
familiar notation if we also adopt the notation

\begin{mathpar}
  \mathsf{let}\; x \;\mathsf{=}\; v \;\mathsf{in}\; P := (\mathsf{new} \; u)(\prefix{u}{@x}P)\mathsf{|}\outputp{u}{v}
\end{mathpar}



