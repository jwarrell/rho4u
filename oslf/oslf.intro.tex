\section{Introduction}\label{sec:introduction} % (fold)

Programmers who work on large scale deployments, like Facebook,
Google, or Microsoft services, know that it is just not cost effective
to write code at scale in an untyped language. Why waste human time
and effort on writing tests (and debugging them) and worrying about
coverage for cases that a compiler can completely and exhaustively
automate? That is why the big three (Facebook, Google, and Microsoft)
all spent tens of millions of dollars each developing typed versions
of javascript. It's cheaper than continuing to throw good money
after bad on commercial development in at industrial scale in an
untyped language. All told, the cost to the industry of this one issue
alone is in the hundreds of millions of dollars.

But, as we move deeper and deeper into the era of distributed
concurrent computing, the sorts of errors that mainstream programming
languages catch with their type systems are only the tip of the
iceberg. The Java type system cannot catch liveness errors. The Rust
type system cannot catch security errors. However, the programming
language semantics community has known for 30 years about techniques
for catching a much wider range of safety and liveness errors. Session
types, spatial and behavioral types are well explored areas bearing
considerable fruit on just these sorts of issues. And, just like with
javascript, it is taking the community ages to get these techniques
into the hands of front line developers.

What if it didn't have to be this way? What if the type system for
spatial and behavioral types could be algorithmically generated from
the specification of the programming language? That's what this paper
is about: an algorithm that takes as input a description of a model of
computation as a rewrite system and \emph{generates} as output a
spatial-behavioral type system for the model.

The formalization of the rewrite system uses Fiore's higher-order
abstract syntax to specify the syntax with binders. This is augmented
with a theory of graphs specifying the source and targets of the
rewrite rules. This yields what amounts to a Cartesian closed category
($\mathsf{CCC}$), call it $\mathcal{C}$. To $\mathcal{C}$ we apply the
following recipe. First we hit is with Yoneda, resulting in a category
of presheaves. We then hit that with a construction described below
turning the homs into complete Heyting algebras. Finally, we take the
Grothendieck construction. The result is that types are pairs
$(\mathbf{U}, \mathbf{X})$ consisting of a sort, $\mathbf{X}$, from
the original lambda theory and a filter on it, $\mathbf{U}$.

The resulting category, denoted by $\mathsf{NT}(\mathcal{C})$, enjoys
a rich logical structure (in fact, it is a topos) and thus provides a
stable means for combining collections of witnesses of various
properties in various ways. Specifically the homs are complete Heyting
algebras and hence enjoy that particular menu of lattice
operations. Additionally, there are products and sums, which can be
made to interact coherently with the lattice operations. Likewise, we
have two different forms of implication.

Further, because the rewrites have been explicitly encoded we get
typed versions of redex constructors, as well as typed versions of
reduction, and modal operators ala Hennessy-Milner logics, all of this
mechanism delivers a powerful behavioral typing
apparatus. Additionally, we find that there are typed versions of the
term constructors. These play in the role of spatial types. 

\subsection{Summary of contributions and outline of paper}

\subsubsection{Summary of contributions}
TBD

\subsubsection{Outline of paper}
TBD

% section introduction (end)
