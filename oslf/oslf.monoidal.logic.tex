\section{Monoidal logic: a motivating example}
In this section we develop a (not so) toy example that motivated your
author's search for an algorithm of this generality. We present a
logic for reasoning about monoids.

\subsection{Finitely generated monoids}
\begin{mathpar}
  \inferrule* [lab=Monoid-Expr] {} {M[G] \bc \mathsf{e} \;\bm\; g \;\bm\; M[G] \mathsf{*} M[G]}
\end{mathpar}

where $g \in G$. The syntax is only slightly unusual. It's almost
standard $\mathsf{BNF}$ except that the grammar is parametric in a set
$G$ of generators. This freely generates a collection of expressions
over $G$ involving $\mathsf{*}$ and $e$, which we write
$\mathcal{L}(M[G])$. We must whack this collection down by the
familiar relations.

\begin{eqnarray*}
  e \mathsf{*} m & = m = & m \mathsf{*} e \\
  (m_{1} \mathsf{*} m_{2}) \mathsf{*} m_{3} & = & m_{1} \mathsf{*} (m_{2} \mathsf{*} m_{3})
\end{eqnarray*}

In other words, formally the monoid is $\mathcal{L}(M[G])\\=$.

\subsection{Monoid logic: syntax and semantics}
\begin{eqnarray*}
  \phi,\psi & \bc & \mathsf{true} \;\bm\; \neg \phi \;\bm\; \phi \& \psi \\
  & \;\bm\; & \mathbf{e} \;\bm\; \mathbf{g} \;\bm\; \phi \mathbf{*} \psi
\end{eqnarray*}

\begin{eqnarray*}
  \meaningof{\mathsf{true}} & = & \mathcal{L}(M[G]) \\
  \meaningof{\neg \phi} & = & \mathcal{L}(M[G]) \backslash \meaningof{\phi} \\
  \meaningof{\phi \& \psi} & = & \meaningof{\phi} \cap \meaningof{\psi} \\
  \meaningof{\mathbf{e}} & = & \{ m \in \mathcal{L}(M[G]) : m = \mathsf{e} \} \\
  \meaningof{\mathbf{g}} & = & \{ m \in \mathcal{L}(M[G]) : m = g \} \\
  \meaningof{\phi \mathbf{*} \psi} & = & \{ m \in \mathcal{L}(M[G]) : \exists m_{1}, m_{2}.m = m_{1} \mathsf{*} m_{2}, m_{1} \in \meaningof{\phi}, m_{2} \in \meaningof{\psi} \}
\end{eqnarray*}

The logic neatly divides into operations on collections of witnesses
(the usual boolean connectives, interpreted as operations on sets),
and logical operations derived from the syntax of monoid
\emph{expressions}. It is completely algorithmically generated. Any
theory presented via generators and relations like this (and hence any
Lawvere theory, and hence a certain class of monads) has a
corresponding logic.

Yet, it is is very expressive. Consider the following formula.

\begin{eqnarray*}
  prime & = & \neg \mathbf{e} \; \& \; \neg (\neg \mathbf{e} \; \mathbf{*}\; \neg \mathbf{e})
\end{eqnarray*}

As the reader may verify, this picks out exactly the primes of any
finitely generated monoid. In fact, an extension of this algorithm was
used to \emph{generate} namespace logic. The extension adds a third
section to the logic that provides an algorithmic treatment of the
Hennessy-Milner style modal connectives.

This analysis was the beginning of a search for the proper expression
of the algorithm that captures not only model-checking semantics like
the one above, but a type and judgment system. The search lead to a
category theoretic treatment. Originally, it seemed that the approach
might be captured by distributive laws amongst monads. However, some
recent no-go theorems for distributive laws showed that the approach
could not work for the parameterization contemplated.

Christian Williams and Mike Stay devised the core of the formalization
of the algorithm considered here. However, there are some key
differences.


