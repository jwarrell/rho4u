\section{A presentation of the semantics of MeTTa}

A presentation of the semantics of MeTTa must therefore provide a monad describing the algebra of states, a structural equivalence quotienting the algebra of states, and some rewrite rules describing state transitions. Such a description is the minimal description that meets the standard for describing models of computation. 


Note that to present such a description requires at least that much expressive power in the system used to formalize the presentation. That is, the system used to present a model of computation is itself a model of computation admitting a presentation in terms of an algebra of states and some rewrites. This is why a meta-circular evaluator is a perfectly legitimate presentation. That is, a presentation of MeTTa’s semantics in MeTTa is perfectly legitimate. Meta-circular presentations are more difficult to unpack, which is why such presentations are typically eschewed, but they are admissible. In fact, a meta-circular evaluator may be the most pure form of presentation.


But, this fact has an important consequence. No model that is at least Turing complete can be “lower level” than any other.

\subsection{Rationale for such a presentation}

The rationale for such a presentation is not simply that this is the way it’s done. Instead, the benefits include

\begin{itemize}
  \item an effective (if undecidable) notion of program equality;
  \item an independent specification allowing implementations;
  \item meta-level computation, including type checking, model checking, macros, computational reflection, etc.
\end{itemize}

\subsection{MeTTa Operational Semantics}
The complexity of MeTTa's operational semantics is somewhere between the simplicity of the $\lambda$-calculus and the enormity of the JVM.

\subsubsection{Algebra of States}

%% Non-terminals are enclosed between $<$ and $>$. 
%% The symbols -$>$ (production),  \textbf{$|$}  (union) 
%% and \textbf{eps} (empty rule) belong to the BNF notation. 
%% All other symbols are terminals.

\paragraph{Terms}
\begin{eqnarray*}
  Term & \bc & \mathsf{(} Term \; [Term] \mathsf{)} \\
  & \;\bm\; & \mathsf{\{} Term \; [Term] \mathsf{\}} \\
  & \;\bm\; & \mathsf{(} Term{} \;\mathsf{|}\; [Receipt] \; \mathsf{.} \; [Term] \mathsf{)} \\
  & \;\bm\; & \mathsf{\{} Term \;\mathsf{|}\; [Receipt] \; \mathsf{.} \; [Term] \mathsf{\}} \\
& \;\bm\; & Atom
\end{eqnarray*}

We impose the equation $\mathsf{\{} \ldots, t, u, \ldots \mathsf{\}} = \mathsf{\{} \ldots, u, t, \ldots \mathsf{\}}$, making terms of this form multisets. Note that for multiset comprehensions this amounts to non-determinism in the order of the terms delivered, but they are still streams. We use $\mathsf{\{}Term\mathsf{\}}$ to denote the set of terms that are (extensionally or intensionally) defined multisets, and $\mathsf{(}Term\mathsf{)}$ to denote the set of terms that are (extensionally or intensionally) defined lists.

We assume a number of polymorphic operators, such as $\pplus$ which acts as union on multisets and append on lists and concatenation on strings, and $::$ which acts as cons on lists and the appropriate generalization for the other data types.

\paragraph{Term sequences}
\begin{eqnarray*}
  [Term] & \bc & \epsilon \\
  & \;\bm \; & Term \\
  & \;\bm \; & Term \; [Term]
\end{eqnarray*}

\paragraph{Bindings}
\begin{eqnarray*}
  Receipt & \bc & ReceiptLinearImpl \\
  & \;\bm \; & ReceiptRepeatedImpl \\
  & \;\bm \; & ReceiptPeekImpl
\end{eqnarray*}
\begin{eqnarray*}
  [Receipt] & \bc & Receipt \\
  & \;\bm \; & Receipt \mathsf{;}\; [Receipt]
\end{eqnarray*}
\begin{eqnarray*}
  ReceiptLinearImpl & \bc & [LinearBind] \\
  LinearBind & \bc & [Name] \; NameRemainder \; \mathsf{\leftarrow} \; AtomSource
\end{eqnarray*}
\begin{eqnarray*}
  [LinearBind] & \bc & LinearBind \\
  & \;\bm \; & LinearBind \;\mathsf{\&}\; [LinearBind]
\end{eqnarray*}
\begin{eqnarray*}
  AtomSource & \bc & Name \\
  & \;\bm \; & Name \mathsf{?!} \\
  & \;\bm \; & Name \mathsf{!?} \mathsf{(} [Term] \mathsf{)} \\
  ReceiptRepeatedImpl & \bc & [RepeatedBind] \\
  RepeatedBind & \bc & [Name] \; NameRemainder \; \mathsf{\Leftarrow} \; Atom
\end{eqnarray*}
\begin{eqnarray*}
  [RepeatedBind] & \bc & RepeatedBind \\
  & \;\bm \; & RepeatedBind \; \mathsf{\&}\; [RepeatedBind] \\
  ReceiptPeekImpl & \bc & [PeekBind] \\
  PeekBind & \bc & [Name] \; NameRemainder \; \mathsf{\leftharpoonup}\; Atom
\end{eqnarray*}
\begin{eqnarray*}
  [PeekBind] & \bc & PeekBind \\
  & \;\bm \; & PeekBind \; \mathsf{\&}\; [PeekBind]
\end{eqnarray*}
\begin{eqnarray*}
  TermRemainder & \bc & \mathsf{...} \; TermVar \\
 & \;\bm \; & \epsilon \\
  NameRemainder & \bc & \mathsf{...} \; \mathsf{@} TermVar \\
& \;\bm \; & \epsilon
\end{eqnarray*}

\paragraph{Literals and builtins}
\begin{eqnarray*}
  Atom & \bc & Ground \\
  & \;\bm \; & Builtin \\
  & \;\bm \; & Var \\
  Name & \bc & \mathsf{\_} \\
  & \;\bm \; & Var \\
  & \;\bm \; & \mathsf{@} Term
\end{eqnarray*}
\begin{eqnarray*}  
  [Name] & \bc & \epsilon \\
  & \;\bm \; & Name \\
  & \;\bm \; & Name \mathsf{,} [Name] \\
  BoolLiteral & \bc & \mathsf{true} \\
 & \;\bm \; & \mathsf{false} \\
  Ground & \bc & BoolLiteral \\
  & \;\bm \; & LongLiteral \\
  & \;\bm \; & StringLiteral \\
  & \;\bm \; & UriLiteral \\
  Builtin & \bc & \mathsf{\bc} \\
 & \;\bm \; & \mathsf{=} \\
 & \;\bm \; & \mathsf{:} \\
  TermVar & \bc & \mathsf{\_} \\
  & \;\bm \; & Var \\
\end{eqnarray*}

\paragraph{States}
\begin{eqnarray*}
  State & \bc & \langle \mathsf{\{}Term\mathsf{\}} \mathsf{,} \mathsf{\{}Term\mathsf{\}} \mathsf{,} \mathsf{\{}Term\mathsf{\}} \rangle
\end{eqnarray*}

We will use $S, T, U$ to range over states and $\mathsf{i} := \pi_{1}$, $\mathsf{k} := \pi_{2}$, and $\mathsf{o} := \pi_{3}$ for the first, second, and third projections as accessors for the components of states. Substitutions are ranged over by $\sigma$, and as is standard, substitution application will be written postfix, e.g. $t\sigma$.

\subsubsection{Rewrite Rules}

\begin{mathpar}
  \inferrule* [lab=Query]{\sigma_{i} = \mathsf{unify}(t',t_{i}), k = \mathsf{\{} (\mathsf{=}\; t_{1} \; u_{1}), \ldots, (\mathsf{=}\; t_{k} \; u_{k}) \mathsf{\}} \pplus k', \mathsf{insensitive}(t',k')}{\langle \mathsf{\{} t' \mathsf{\}} \pplus i, k, o \rangle \to \langle i, k, \mathsf{\{} u_{i}\sigma_{i} \mathsf{\}} \pplus o \rangle} \\
  \and
  \inferrule* [lab=Chain]{\sigma_{i} = \mathsf{unify}(u,t_{i}), k = \mathsf{\{} (\mathsf{=}\; t_{1} \; u_{1}), \ldots, (\mathsf{=}\; t_{k} \; u_{k}) \mathsf{\}} \pplus k', \mathsf{insensitive}(u,k')}{\langle i, k, \mathsf{\{} u \mathsf{\}} \pplus o \rangle \to \langle i, k, \mathsf{\{} u_{i}\sigma_{i} \mathsf{\}} \pplus o \rangle} \\
  \and
  \inferrule* [lab=Transform]{\sigma_{i} = \mathsf{unify}(t,t_{i}), k = \mathsf{\{} t_{1}, \ldots, t_{k} \mathsf{\}} \pplus k',\mathsf{insensitive}(t,k')}{\langle \mathsf{\{} \mathsf{(}\mathsf{transform}\; t \; u\mathsf{)} \mathsf{\}} \pplus i, k, o \rangle \to \langle i, k, \mathsf{\{} u\sigma_{i} \mathsf{\}} \pplus o \rangle} \\
  \and
  \inferrule* [lab=AddAtom1]{}{\langle \mathsf{\{} \mathsf{(} \mathsf{addAtom}\; t\mathsf{)}\mathsf{\}}  \pplus i, k, o \rangle \to \langle i, k \pplus \mathsf{\{} t\mathsf{\}},  \mathsf{\{} \mathsf{()}\mathsf{\}} \pplus o \rangle} \\
  \and
  \inferrule* [lab=AddAtom2]{\langle i_{1}, k_{1}, o_{1}\rangle \to \langle i_{2}, k_{2}, o_{2} \rangle, k_{3} = \mathsf{\{} \mathsf{(} \mathsf{addAtom}\; t\mathsf{)}\mathsf{\}} \pplus k_{1}}{\langle i_{1}, k_{3}, o_{1}\rangle \to \langle i_{2}, \mathsf{\{} \mathsf{(} \mathsf{addAtom}\; t\mathsf{)}, t\mathsf{\}} \pplus k_{2}, \mathsf{\{} \mathsf{()}\mathsf{\}} \pplus o_{2} \rangle} \\
  \inferrule* [lab=RemAtom1]{}{\langle \mathsf{\{} \mathsf{(} \mathsf{remAtom}\; t\mathsf{)}\mathsf{\}}  \pplus i, \mathsf{\{} t \mathsf{\}} \pplus k, o \rangle \to \langle i, k,  \mathsf{\{} \mathsf{()}\mathsf{\}} \pplus o \rangle} \\
  \and
  \inferrule* [lab=RemAtom2]{\langle i_{1}, k_{1}, o_{1}\rangle \to \langle i_{2}, k_{2}, o_{2} \rangle, k_{3} = \mathsf{\{} \mathsf{(} \mathsf{remAtom}\; t\mathsf{)} \mathsf{\}} \pplus \mathsf{\{} t \mathsf{\}} \pplus k_{1}}{\langle i_{1}, k_{3}, o_{1}\rangle \to \langle i_{2}, \mathsf{\{} \mathsf{(} \mathsf{remAtom}\; t\mathsf{)}\mathsf{\}} \pplus k_{2}, \mathsf{\{} \mathsf{()}\mathsf{\}} \pplus o_{2} \rangle} \\
\end{mathpar}

Where $\mathsf{insensitive}(t,k)$ means that $\mathsf{(} \mathsf{=}\; t'\; u \mathsf{)} \in k \Rightarrow \neg \mathsf{unify}(t,t')$.


